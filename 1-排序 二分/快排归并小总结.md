# 排序

【 [题目链接]([活动 - AcWing](https://www.acwing.com/activity/content/11/) )】

### 快排

① 快排是基于递归，那么就需要设置递归的基线条件

② 快排是一个确定中间值，然后两个指针迭代的过程。简单来说，是确定当前参与递归的`区间中间值mid = a[(l+r) >> 1]`,然后`左端指针i`和`右端指针j`迭代移动，常规的左端小于中点值，右端大于中点值就移动，倘若是都停止了，说明不满足不满足了，就交换。

③ 注意递归的区间，容易出现`SE`

④ `if(i < j ) swap(a[i],a[j]);`的if不能省略

原因是这种的
    [原因分析](img/原理.jpg)






### 归并排序

整体来说，不是特别难理解

① 依旧是基于递归

```
    merge_sort(a,l,mid);
    merge_sort(a,mid+1,r);
```



② 用区间作为处理的对象，因此处理的循环变成了

```
​```cpp
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
​```
```

③ 最后是要将当前轮中，因为不满足条件，没有放进tmp数组中的数据，放进去，以及将临时数组中数据放回原数组中

```
while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
```



