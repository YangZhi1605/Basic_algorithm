# 最短路和最小生成树相关总结

## 四个最短路算法

### dijkstra算法
#### 应用领域
解决所有的边权是正数的单源最短路。朴素版dijkstra算法解决稠密图，时间复杂度$O(n^2)$；堆优化版本的dijkstra算法解决稀疏图，时间复杂度$O(mlogn)$

#### 朴素版dijkstra算法 —— 稠密图
##### 算法大致的思想
1、稠密图使用邻接矩阵存储
2、最短路算法要对整体有个流程，比如整体来说都会有输入点和边，根据边数建立邻接矩阵或者邻接表的图，建图的时候注意是有向图还是无向图，以及后续的调用最短路算法，最终判断最短路是否靠谱。<br>
因为是找最短，这几个算法中，都存在把维护距离的dist数组初始化为正无穷的思想，然后逐渐从最大值中选取最小值嘛。<br>
对于朴素版dijkstra算法而言，有点像暴力吧，第一个点的最短路已经确定了，是dist[1] = 0,那么<br>
对于剩下的n-1个点，就走n-1个循环吧(暂时这种理解，假如有偏僻再更新)，在每个循环中，都放置一个记录全局最短路径的变量t,然后干这个事：<br>
更新出当前轮次中的全局最短的结点，存储在t中，再用这个去更新出其他点的能够出现的最短路。那么就是两个事儿：找全局最小，利用全局最小，更新其他最小。<br>



对于这1到n的每个点，考虑两种情况<br>
1、当前的j没有被st数组记录过状态，同时<br>
2.1、要么用与记录最小值的t仍然是-1，直接没有被修改过<br>
2.2、要么记录最小值的t已经被修改赋值过了，但是现在出现了一个新的，更短的距离路径<br>
```cpp
if(!st[j] && (t == -1 || dist[t] > dist[j]) )
```
##### 算法的板子
```cpp
void dijkstra(){
	//处理距离数组dist,先把所有的点置为正无穷 
	memset(dist,0x3f,sizeof dist);
	//因为题目中是从1号点开始走，就表示为
	dist[1] = 0;
	
	//n-1次循环 这里为什么n-1次循环，是有点迷糊的 
	for(int i = 0;i < n-1;i++){
		int t = -1;//t记录的是全局最小值
		//处理n个点，目的是更新出当前循环下的全局最小
		for(int j = 1;j <= n;j++) {
			//对于每个点有三种处理情况
			//1、当前的j没有被st数组记录过状态，同时 
			//2.1、要么用与记录最小值的t仍然是-1，直接没有被动过
			//2.2、要么记录最小值的t已经被赋值过了，但是现在出现了一个更短的距离路径
			if(!st[j] && (t == -1 || dist[t] > dist[j]) ){
				t = j;
			}
		}
		
		//把这个点j 放到表示已经找到最短路径的数组st中
		st[t] = true;
		//使用全局最小
		//用目前的最短路径de "点t" 去更新出其他1~n能获得的最短路径 
		for(int k = 1; k <= n;k++ ){
			dist[k] = min(dist[k],dist[t]+g[t][k]);
		}
	}
}
```
##### 算法的注意事项
注意距离数组dist的意思,dist数组是维护1号点到当前这点的距离。<br>
其次是注意寻找全局最小的t的逻辑

<hr>

#### 堆优化版dijkstra算法 —— 稀疏图
##### 算法大致的思想
稀疏图是主要是使用邻接表，但是倘若是kruskal算法里那种维护稀疏图的连通块的题目，就主要使用并查集解决。<br>
想法其实和宽搜差不多，将最短距离和结点编号使用数对、结构体等维护起来，放到队列中，在队列不空的时候，取队头，去除队头，拓展队头，如果拓展出来的最短路更小，就入队。


##### 算法的板子
```cpp
void dijkstra(){
	//初始化距离数组
	memset(dist,0X3f,sizeof dist) ;
	dist[1] = 0;
	
	//难点应该是背怎么创建小根堆，因为其他和宽搜差不多
	
	/*
	
	Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，
	但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式
	priority_queue<Type, Container, Functional>
	*/ 
	
	//使用STL容器建立小根堆
	priority_queue<PII,vector<PII>,greater<PII>> heap;
	//对当前数对而言，first属性是距离，second属性是结点编号 
	heap.push({0,1}) ; 
	
	//当队列不为空的时候，进行操作
	while(heap.size()) {
		//取出当前的距离最小值，想要最小值，对于小根堆而言，就是堆顶
		auto t = heap.top();
		heap.pop();
		
		int dis = t.first;
		int var = t.second;
		
		//如果当前染探索的结点已经被放到st数组统计过最短路径了，那么直接跳过 
		if(st[var]) continue;
		//否则统计当前结点
		st[var]  = true;
		
		//用当前统计的这个结点，来探索其他结点
		for(int i = h[var];i != -1;i = ne[i]) {
			int node = e[i];
			
			//比较直接走到j的距离和先走到结点var，在根据w[i]的距离从i走到j的总和，谁到，保留最小的 
			if(dist[node] > dis + w[i]){
				dist[node] = dis + w[i];
				//将更新出来的数据插入到堆中
				heap.push({dist[node],node}) ;
				//在队列中，循环这个过程 
			}
		} 
	}
}

```
##### 算法的注意事项
难点应该是背怎么创建小根堆，因为其他和宽搜差不多。同时了，涉及到邻接表的题，怎么遍历邻接表以及取到当前遍历元素的值参与更新，也是一个值得记忆的点。

<hr>

### bellman_ford算法
#### 应用领域 —— 不存在稠密图、稀疏图的区分
解决存在负权边的单源最短路问题，时间复杂度$O(nm)$，不存在稠密图或者稀疏图的说法了，似乎都就可以用
##### 算法大致的思想
理解起来了，算是暴力+递推吧，在初始化距离数组之后，找最短路的逻辑是判断直接到结点b的距离更小还是，先到a再根据边权到达b的总距离更近。所以也可以理解为什么要备份了，因为先到达a这里算是前一个状态的信息了，假如不备份，是会被影响的。

##### 算法的板子
```cpp
void bellman_ford(){
	//初始化距离数组为很大很大的值 
	memset(dist,0x3f,sizeof dist) ;
	dist[1] = 0;
	
	//题目要的是"最多经过 k 条边的最短距离"，现在就处理k条边
	for(int i = 0;i < k;i++) {
		//因为每次迭代进来处理一条边，就会影响原本的数据
		//所以操作备份数组 
		memcpy(backup,dist,sizeof dist);
		
		//由现在有的边，来推断相应的点们的最短路径
		for(int i = 0;i < m;i++){
			int a = edges[i].a;
			int b = edges[i].b;
			int w = edges[i].w;
			
			//老规矩，判断是直接到b的距离小,还是先到a在到b的距离小
			//只是因为担心单纯到a的距离可能被修改过，所有使用备份数组中的数据来操作 
				/*
				1 2 1
				2 3 1
				1 3 3
				*/
			//输出出来就看懂了 
//            printf("当前的a是%d,b是%d,对应的最短路径中，dist[b] = %d,backup[a] = %d,backup[a]+w = %d\n",
//			a,b,dist[b],backup[a],backup[a]+w);
			dist[b] = min(dist[b],backup[a]+w);
		}
		
	}
}
```
##### 算法的注意事项
这个算法在存储图的信息上可以随意，所以直接薅结构体都行，同时这里的备份的想法，值得注意。

<hr>

### spfa算法
#### 应用领域 —— 稀疏图
解决存在负权边的单源最短路问题，时间复杂度$O(m)$，最坏$O(nm)$，用在稀疏图上的
#### spfa算法求最短路
##### 算法大致的思想
稀疏图的话，宽搜中队列的玩法+遍历邻接表。
##### 算法的板子
```cpp
void spfa(){
	memset(dist,0x3f,sizeof dist);
	dist[1] = 0;
	//创建一个队列，并将已经确认最短路径的1号点加入队列 
	queue<int> q;
	q.push(1);
	//标记1号点 
	st[1] = true;
	
	//老规矩，当队列不空的时候进行
	while(q.size()) {
		auto t = q.front();
		q.pop();
		
		//标记不在队列中的点
		st[t] = false;
		
		for(int i = h[t]; i != -1;i = ne[i]) {
			int j =e[i];
			if(dist[j] > dist[t] + w[i]){
				//找到更小的最短路，更新1号点到j的距离 
				dist[j] = dist[t] + w[i];
				//这里加的这个if，有点迷糊
				//理解是，上面确实是找到最短路了，但是需要判断之前是不是已经找过了
				//假如没有，才能入队，并标记 
				if(!st[j]){
					q.push(j);//入队
					st[j] = true;//标记 
				}
			}
		}
	}
	
}

```
##### 算法的注意事项
这里需要注意，拓展出来的结点，假如能够更新最短距离，需要判断之前是否已经确定过最短路了，不能重复入队

#### spfa算法判断负环
##### 算法大致思想
邻接表的话，宽搜中队列的用法+遍历邻接表+统计参与spfa更新的数量，最后使用抽屉原理判断是否存在负环
##### 算法的板子
```cpp
bool spfa(){
	// 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，
	//由抽屉原理一定有两个点相同，所以存在环。
	queue<int> q;
	
	//把现在的1到n号点都当到队列中，并标记已经入队 
	for(int i = 1;i <= n;i++){
		q.push(i);
		st[i] = true;
	}
	while(q.size()){
		auto t = q.front();
		q.pop();
		st[t] = false;
		
		for(int i = h[t];i != -1;i  = ne[i]) {
			int j = e[i];
			if(dist[j] > dist[t]+w[i]){
				dist[j] = dist[t] + w[i];
				cnt[j] = cnt[t]+1;
				
				//抽屉原理 --> 用于解决环的问题 
				/*
				抽屉原理的一般含义为："如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，
				假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。
				*/ 
				if(cnt[j] >= n) return true;
				
				//同时处理，如果这个j 没有在队列中，就加入队列
				if(!st[j]) {
					q.push(j);
					st[j] = true;
				}
			}
	
		}
	}
	
	return false;
	
	
}
```
##### 算法注意事项
不用初始化了，可以理解为：因为不是去更新最短距离嘛


<hr>

### Floyd算法
#### 应用领域 —— 稠密图
解决多源最短路问题，比如给定多个起点和终点，让求它们的最短路，时间复杂度$O(n^3)$，用于稠密图
##### 算法大致的思想
浅类似dijkstra算法，只是迪杰斯特拉中是n-1次循环。与此同时了，少了迪杰斯塔拉中循环全局最小，利用全局最小更新的想法，这儿是直接暴力找了
##### 算法的板子
```cpp
void floyd(){
	//外层的k是因为k行，内层就是常规的dijkstra更新最短路径的思想或者说是，邻接矩阵更新，但不是dijkstra的玩法 
	for(int k = 1;k <= n;k++){
		for(int i = 1;i <= n;i++){
			for(int j = 1;j <= n;j++)
				d[i][j] = min(d[i][j],d[i][k]+d[k][j]);//这里循环放置的顺序，也是迷惑点 
		}
	}
}
```
##### 算法的注意事项
注意dist数组维护的是当前的点到另外的点之间的距离，不是起点1了，因为多源的缘故，起点是多处。同时邻接矩阵在找最短路这块，也是判断是直接从i到j更近还是，先到k再到j更近了。<br>
注意主函数中手动初始化距离数组
```cpp
    //初始化矩阵 -- 注意这里没有初始化什么矩阵地图，直接初始化的距离数组了 
	//这里是矩阵，那么边长都是n 
	for(int i = 1; i <= n;i++) {
		for(int j = 1;j <= n;j++){
			if(i == j) d[i][j] = 0;
			else d[i][j] = INF;
		}
	}
```


### 小总结1
1、根据题目中有没有负权边决定是用迪杰斯特拉还是bellman_ford/spfa。
2、假如是多起点，那么直接floyd了
3、看题目数据，稠密图使用邻接表，稀疏图使用邻接表，邻接表这块，大多数有点像宽搜的板子了

<hr>
## 两个最小生成树

### prim 算法
#### 应用领域
稠密图中的最小生成树
##### 算法大致的思想
浅类似Dijkstra了，也是寻找全局最小，利用全局最小去更新。

##### 算法的板子
```cpp
int prim(){
	//初始化距离数组 
	memset(dist,0x3f,sizeof dist);
	//sum中存放的是最小生成树的树边权重之和
	int sum = 0;
	
	for(int i = 0;i < n;i++) {
		int t = -1; //记录全局最小的结点编号
		
		//注意下面三层结构和dijkstra一样，都是彼此独立的结构，没有嵌套
		//都是必须的功能模块 
		
		//寻找满足最短路径的t 
		for(int j = 1; j <= n;j++) {
			if(!st[j] && (t == -1 || dist[t] > dist[j]))
				t= j;
		}
		//判断t是否符合要求 
		//如果当前的点已经不是第一个点，以及距离最小的点为正无穷 
		//则说明当前距离最近的点，确实都是正无穷了，即当前的图，不连通 
		if(i && dist[t] == INF) return INF;
		if(i) sum += dist[t];	
		
		//用t去更新出其他点
		//注意这里是g[t][j]
		//对于dijskstra而言，是dist[t] + g[t][j]
		//因为对于dijkstra而言，dist数组维护的是1号点到t的最短路径
		//最小生成树中维护的是j到现在集合中其他点的最短路 
		for(int j = 1;j <= n;j++) {	
			dist[j] = min(dist[j],g[t][j]);
		}
			
		st[t] = true;//标记t已经用过了 
		
	}
	
	return sum; 
	
}
```
##### 算法的注意事项
最小生成树中维护的是j到现在集合中其他点的最短路 .
```c
int ans = prim();
	if(ans == INF) puts("impossible");
	else cout << ans << endl;
```



<hr>

### Kruskal算法
#### 应用领域
稀疏图的最小生成树
##### 算法大致的思想
存储图的信息上，和bellmam_ford一样随意了，至于最小生成树的判断上，需要结合并查集维护连通块的思想。
##### 算法的板子
```c

/*
kruskal算法的核心是按照连通块来理解 
连通块的处理，那么就可以使用并查集了 
*/
struct Edge{
	int a,b,w;
}edges[N];
 
bool cmp(Edge &a,Edge &b){
	
	return a.w < b.w; 
}

int find(int x){
	if(fa[x] != x) fa[x] =find(fa[x]);
	return fa[x];
}

void kruskal(){
	//对存放数据的结构体按照权重从小到大重新排序
	sort(edges,edges+m,cmp) ;
	//初始化并查集 注意是对点进行并查集的初始化 
	for(int i = 1;i <= n;i++)  fa[i] = i;
	
	//从小到大枚举所有边 
	for(int i = 0; i < m;i++) {
		int a = edges[i].a;
		int b = edges[i].b;
		int c = edges[i].w;
		
		//找到a和b的祖宗结点
		a = find(a);
		b = find(b) ;
		
		//如果a 和 b不在一个连通块上
		if(a != b) {
			//将a连在b上
			fa[a] = b;
			//统计现在的权重和 
			ans += c;
			//统计参与最小生成树的结点数目 
			cnt ++; 
		}
	}
}

```
##### 算法的注意事项
注意最后如何判断是最小生成树吧
```c
//输出
	//n个点，只能刚好有n-1边才能生成最小生成树 
	if(cnt < n-1) puts("impossible");
	else cout << ans <<endl;
	
```

### 小总结2
普利姆算法像Dijkstra，克鲁斯卡尔算法一个像bellman_ford

## 染色法判定二分图
##### 算法大致的思想 
##### 算法板子
```CPP
int h[N],e[M],ne[M],idx; //注意，因为是无向图，那么存储指针和结点指的数据，应该开结点数的两倍 
int color[N];//表示每个点的颜色，-1表示未染色， 0表示白色，1表示黑色

/*
主要是搜索，打标记，同时用传入的结点，再搜索，判断是否染色矛盾 
*/


void add(int a,int b) {
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx ++;
}


//参数u存储当前的结点。c存储当前的颜色
bool dfs(int u,int c){
	color[u] = c;//将传入的点染色
	
	//遍历邻接表
	for(int i = h[u];i != -1;i = ne[i]) {
		int j = e[i];
		//如果当前点没有染过色 注意是在当前点没有被染色过的时候，才进去搜索 
		if(color[j] == -1) {
			//用!c切换传入进去染色的标记c 
			if(!dfs(j,!c)) return false;
			//如果当前的这个点已经被染色过了，但是和我传入参数染的结点颜色相同，就矛盾了，返回flase 
		}
		//如果被染过色，需要判断染色是否矛盾 
		else if(color[j] == c) return false;
	}
	
	return true;
}
```
##### 算法注意事项 —— 注意是用在稀疏图上的

<hr>

## 匈牙利算法解决二分图匹配问题
##### 算法大致的思想
##### 算法板子

```c++
int n1,n2,m; // n1表示第一个集合中的点数，n2表示第二个集合中的点数
// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int h[N],e[M],ne[M],idx; 
int match[N];// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];// 表示第二个集合中的每个点是否已经被遍历过

void add(int a,int b){
	e[idx] = b;
	ne[idx] = h[a];
	h[a] = idx ++;
}


//找男朋友的原则 
bool find(int x) {
	//枚举女孩子看上的所有男孩子
	for(int i = h[x]; i != -1;i = ne[i]){
		int j = e[i];
		//如果这个男孩子没有考虑过对象
		if(!st[j]) {
			//标记女孩子x占据了男孩子j
			st[j] =  true; 
			//核心来了
			//如果
			//如果第二个集合中的点j当前是没有匹配第一个集合中
			//或者第二个集合中已经匹配到的第一个集合中点，是可以再找其他其他点的
			//就让当前这第二个集合中的点，被x占据吧 
			if(match[j] == 0 || find(match[j])){
				match[j] = x;
				return true;
			}
		}
	}
	return false;
}
```



##### 算法注意事项 —— 注意是用在稀疏图上的


