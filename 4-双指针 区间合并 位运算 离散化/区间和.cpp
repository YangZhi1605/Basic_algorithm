#include <iostream> 
#include <vector> 
#include <algorithm>
#define x first
#define y second
/*
上一次交这个，是在七个月之前了，wc 

确实整体来说，只是这个离散的想法需要注意，其他是库函数的熟悉以及常规的模拟了 
*/


/*
关于为什么离散化

此题第一次看确实没看懂，所以此处略作分析，为什么要离散化呢，因为存储的下标实在太大了，如果直接开这么大的数组，根本不现实，第二个原因，本文是数轴，要是采用下标的话，可能存在负值，所以也不能，所以有人可能会提出用哈希表，哈希表可以吗？答案也是不可以的，因为哈希表不能像离散化那样缩小数组的空间，导致我们可能需要从-e9遍历到1e9（此处的含义就是假如我们需要计算1e-9和1e9区间内的值，那我们需要从前到后枚举，无论该值是否存在），因为哈希表不能排序，所以我们一般不能提前知道哪些数轴上的点存在哪些不存在，所以一般是从负的最小值到正的最大值都枚举一遍，时间负责度太高，于是就有了本题的离散化。

离散化的本质，是映射，将间隔很大的点，映射到相邻的数组元素中。减少对空间的需求，也减少计算量。

其实映射最大的难点是前后的映射关系，如何能够将不连续的点映射到连续的数组的下标。此处的解决办法就是开辟额外的数组存放原来的数组下标，或者说下标标志，本文是原来上的数轴上的非连续点的横坐标。
此处的做法是是对原来的数轴下标进行排序，再去重，为什么要去重呢，因为本题提前考虑了前缀和的思想，其实很简单，就是我们需要求出的区间内的和的两端断点不一定有元素，提前加如需要求前缀和的两个端点，有利于我们进行二分搜索，其实二分搜索里面我们一般假定有解的，如果没解的话需要特判，所以提前加入了这些元素，从而导致可能出现重复元素。

本文你用于存储这个关系的数组是disc[N];特地说明下，为什么要开300000+10呢，因为我前面说过了提前考虑了前缀和的因素，加上了2*m个点，又因为怕出现数组越界，多加了10。什么时候会用完300000个空间呢，那就是无重复元素，外加n和m都是1e5次方的打下。

下一步就是写提前数轴点对应的映射后的数组的下标的函数课，此题用的是二分，log(n + 2 * m)

作者：此题有解否
链接：https://www.acwing.com/solution/content/2321/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 
*/


using namespace std;
const int N = 300010;//自己十万个点，然后左右端点各自二十万，总共三十万。 
int a[N],s[N];//需要用到前缀和的知识来求区间和 
int n,m;
typedef pair<int,int> PII;
vector<int> disc; //存储需要离散化的值 
vector<PII> ins,query;// 插入操作和最后求n次询问的值 

int find(int x){ // 找到第一个大于等于x的位置
	int l = 0,r = disc.size()-1;
	
	while(l < r){
		int mid = (l+r) >> 1;
		if(disc[mid] >= x) r=mid; //注意这里是在离散化数组disc中进行二分 
		else l = mid + 1;
	}
	return l+1;// 映射到1, 2, ...n
}

int main(){
	//优化cin cout 
	cin.tie(0);
    ios::sync_with_stdio(false);
    
	cin >> n >> m;
	for(int i = 0;i < n;i++) {
		int num,c;
		cin >> num >> c;
		//存入的该数对表示在x的位置上插入c
		ins.push_back({num,c});
		
		//把需要离散化的数，放到对应的离散化数组中 
		disc.push_back(num);
	}
	
	//把m个询问先存储起来
	while(m--) {
		int l,r;
		cin >> l >> r;
		//暂时把已经有的询问区间存起来
		query.push_back({l,r}) ;
		
		//同时把左右区间也放到离散化数组中，因为两个端点也是需要离散化的
		disc.push_back(l) ;
		disc.push_back(r);
	}
	
	//对需要离散化的数值去重
	sort(disc.begin(),disc.end()) ;
	disc.erase(unique(disc.begin(),disc.end()),disc.end());
	//unique方法可以筛选出不同的，但是相同的数据，仍然存在，并且接在当前彼此不同的序列的后面 
	
	
	//落实数据的插入
	for(auto it : ins) {
		//找到需要离散化的item.x的位置,也可以理解为找到离散话结果 
		int pos = find(it.x);
		//落实插入
		a[pos]  += it.y;
	}
	
	//经过插入c之后，要求区间和了，此时就是需要前缀和的预处理来构建前缀和公式
	for(int i = 1; i <= disc.size();i++)  s[i] = s[i-1] + a[i];
	
	//处理m次询问
	for(auto it:query) {
		//在m次询问这里注意，咱们已经讲询问的区间存储起来了，但是当前这个端点[l,r]也是需要找到其离散化的值
		//才能去操纵离散化后再预处理得到的的前缀和数组s 
		int l = find(it.x);
		int r = find(it.y);
		cout << s[r] - s[l-1]<< endl;
	}
	return 0;
}
